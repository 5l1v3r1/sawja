<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="generator" content=
"HTML Tidy for Linux/x86 (vers 11 February 2007), see www.w3.org" />
<title>Sawja tutorial</title>
<meta http-equiv="Content-Type" content=
"text/html; charset=us-ascii" />
<meta name="generator" content="pandoc" />
<link rel="stylesheet" href="style-tut.css" type="text/css" media=
"all" />
</head>
<body>
<h1 class="tutorial-title">Sawja tutorial<br />
<img src="http://www.inria.fr/images/ti_dessous.gif" width="329"
height="18" alt="-----------------------" /></h1>
<div id="TOC">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#global-architecture">Global architecture</a>
<ul>
<li><a href="#jprogram-module"><em>JProgram</em> module</a></li>
<li><a href="#jcra-jrta-and-jrrta-modules"><em>JCRA</em>,
<em>JRTA</em> and <em>JRRTA</em> modules</a></li>
<li><a href="#jnativestubs-module"><em>JNativeStubs</em>
module</a></li>
<li><a href="#jcontrolflow-module"><em>JControlFlow</em>
module</a></li>
<li><a href="#jbir-and-a3bir-modules"><em>JBir</em> and
<em>A3Bir</em> modules</a></li>
<li><a href="#jprinthtml-module"><em>JPrintHtml</em>
module</a></li>
</ul>
</li>
<li><a href="#tutorial">Tutorial</a>
<ul>
<li><a href="#loading-and-printing-a-program">Loading and printing
a program</a></li>
<li><a href="#transforming-a-program-with-bir">Transforming a
program with <em>Bir</em></a></li>
<li><a href="#writing-your-own-html-printer">Writing your own HTML
printer</a></li>
</ul>
</li>
</ul>
</div>
<div id="introduction">
<h1><a href="#TOC">Introduction</a></h1>
<p><em>Sawja</em> is a library written in <em>OCaml</em>, relying
on the <em>Javalib</em> to provide a high level representation of
<em>Java</em> byte-code programs. Whereas <em>Javalib</em> is
dedicated to class per class loading, <em>Sawja</em> introduces a
notion of program thanks to control flow algorithms. For instance,
a program can be loaded using various algorithms like <em>Class
Reachability Analysis</em> (<em>CRA</em>), a variant of <em>Class
Hierarchy Analysis</em> algorithm (<em>CHA</em>) or <em>Rapid Type
Analysis</em> (<em>RTA</em>). For now, <em>RTA</em> is the best
compromise between loading time and precision of the call graph. A
version of <em>XTA</em> is coming soon. To get more information
about control flow graph algorithms and their complexity, you can
consult the paper of Frank Tip and Jens Palsberg <a href="#fn1"
class="footnoteRef" id="fnref1" name="fnref1"><sup>1</sup></a>.</p>
<p>In <em>Sawja</em>, classes and interfaces are represented by
interconnected nodes belonging to a common hierarchy. For example,
given a class node, it's easy to access its super class, its
implemented interfaces or its children classes. The next chapters
will give more information about the nodes and program data
structures.</p>
<p>Moreover, <em>Sawja</em> provides some stack-less intermediate
representations of code, called <em>JBir</em> and <em>A3Bir</em>.
Such representations open the way to many analyses which can be
built upon them more naturally, better than with the byte-code
representation (e.g. <em>Live Variable Analysis</em>). The
transformation algorithm, common to these representations, has been
formalized and proved to be semantics-preserving<a href="#fn2"
class="footnoteRef" id="fnref2" name="fnref2"><sup>2</sup></a>.</p>
<p><em>Sawja</em> also provides functions to map a program using a
particular code representation to another.</p>
</div>
<div id="global-architecture">
<h1><a href="#TOC">Global architecture</a></h1>
<p>In this section, we present the different modules of
<em>Sawja</em> and how they interact together. While reading the
next sections, we recommend you to have a look at <em>Sawja</em>
API at the same time.</p>
<div id="jprogram-module">
<h2><a href="#TOC"><em>JProgram</em> module</a></h2>
<p>This module defines:</p>
<ul>
<li>the types representing the class hierarchy.</li>
<li>the program structure.</li>
<li>some functions to access classes, methods and fields (similar
to <em>Javalib</em> functions).</li>
<li>some functions to browse the class hierarchy.</li>
<li>a large set of program manipulations.</li>
</ul>
<p>Classes and interfaces are represented by
<strong>class_node</strong> and <strong>interface_node</strong>
record types, respectively. These types are parametrized by the
code representation type, like in <em>Javalib</em>. These types are
private and cannot be modified by the user. The only way to create
them is to use the functions <strong>make_class_node</strong> and
<strong>make_interface_node</strong> with consistent arguments. In
practice, you will never need to build them because the class
hierarchy is automatically generated when loading a program. You
only need a read access to these record fields.</p>
<p>The program structure contains:</p>
<ul>
<li>a map of all the classes referenced in the loaded program.
These classes are linked together through the node structure.</li>
<li>a map of parsed methods. This map depends on the algorithm used
to load the program (<em>CRA</em>, <em>RTA</em>, ...).</li>
<li>a static lookup method. Given the calling class name, the
calling method signature, the invoke kind (virtual, static, ...),
the invoked class name and method signature, it returns a set of
potential couples of (<strong>class_name</strong>,
<strong>method_signature</strong>) that may be called.</li>
</ul>
</div>
<div id="jcra-jrta-and-jrrta-modules">
<h2><a href="#TOC"><em>JCRA</em>, <em>JRTA</em> and <em>JRRTA</em>
modules</a></h2>
<p>Each of these modules implements a function
<strong>parse_program</strong> (the signature varies) which returns
a program parametrized by the <strong>Javalib.jcode</strong>
representation.</p>
<p>In <em>RTA</em>, the function <strong>parse_program</strong>
takes at least, as parameters, a class-path string and a program
entry point. The <strong>default_entrypoints</strong> value
represents the methods that are always called by <em>Sun JVM</em>
before any program is launched.</p>
<p>In <em>CRA</em>, the function <strong>parse_program</strong>
takes at least, as parameters, a class-path string and a list of
classes acting as entry points. The
<strong>default_classes</strong> value represents the classes that
are always loaded by <em>Sun JVM</em>.</p>
<p><em>JRRTA</em> is a refinement of <em>RTA</em>. It first calls
<em>RTA</em> and then prunes the call graph.</p>
<p>If we compare these algorithms according to their precision on
the call-graph, and their cost (time and memory consumption), we
get the following order : <em>CRA</em> &lt; <em>RTA</em> &lt;
<em>RRTA</em> &lt; <em>XTA</em>.</p>
</div>
<div id="jnativestubs-module">
<h2><a href="#TOC"><em>JNativeStubs</em> module</a></h2>
<p>This module allows to define stubs for native methods,
containing information about native method calls and native object
allocations. Stubs can be stored in files, loaded and merged. The
format to describe stubs looks like:</p>
<pre>
<code>    Method{type="Native" class="Ljava/lang/String;"
           name="intern" signature="()Ljava/lang/String;"}{
      VMAlloc{
        "Ljava/lang/String;"
        "[C"
      }
    }


    Method{type="Native" class="Ljava/io/UnixFileSystem;"
           name="getLength" signature="(Ljava/io/File;)J"}{
      Invokes{
        Method{type="Java" class="Ljava/lang/String;"
               name="getBytes" signature="(Ljava/lang/String;)[B"}
        }
    }
</code>
</pre>
<p><em>JRTA</em> admits a stub file as optional argument to handle
native methods.</p>
</div>
<div id="jcontrolflow-module">
<h2><a href="#TOC"><em>JControlFlow</em> module</a></h2>
<p><em>JControlFlow</em> provides many functions related to class,
field an method resolution. Static lookup functions for
<strong>invokevirtual</strong>, <strong>invokeinterface</strong>,
<strong>invokestatic</strong> and <strong>invokespecial</strong>
are also present.</p>
<p>This module also contains an internal module <strong>PP</strong>
which allows to navigate through the control flow graph of a
program.</p>
</div>
<div id="jbir-and-a3bir-modules">
<h2><a href="#TOC"><em>JBir</em> and <em>A3Bir</em>
modules</a></h2>
<p>These modules both declare a type <strong>t</strong> defining an
intermediate code representation. Both representations are
stack-less. <em>A3Bir</em> looks like a three-address code
representation whereas expressions in <em>JBir</em> can have
arbitrary depths.</p>
<p>Each module defines a function <strong>transform</strong> which
takes as parameters a concrete method and its associated
<strong>JCode.code</strong>, and returns a representation of type
<strong>t</strong>. This function coupled with
<strong>JProgram.map_program2</strong> can be used to transform a
whole program loaded with <em>RTA</em> algorithm for example.</p>
</div>
<div id="jprinthtml-module">
<h2><a href="#TOC"><em>JPrintHtml</em> module</a></h2>
<p>This module provides one function per code representation to
dump a program into a set of <strong>.html</strong> files (one per
class) related together by the control flow graph. Each printing
function takes as parameters the program, the name of the output
directory and a type <strong>info</strong>. The type
<strong>info</strong> is used to insert custom annotations at
different levels : class, method, field and program point. A value
<strong>void_info</strong> is also given and can be used by
default.</p>
<p>In order to print your own code representations, this module
also provides a functor <em>Make</em> that can be instantiated by a
module of signature <em>PrintInterface</em>. This functor generates
a module of signature <em>HTMLPrinter</em> containing a function
<strong>print_program</strong>, similar to the others printing
functions present in <em>JPrintHtml</em>. We will give an example
in the tutorial.</p>
</div>
</div>
<div id="tutorial">
<h1><a href="#TOC">Tutorial</a></h1>
<p>To begin this tutorial, open an <em>OCaml</em> toplevel, for
instance using the <em>Emacs</em> <strong>tuareg-mode</strong>, and
load the following libraries in the given order:</p>
<pre>
<code>    #load "str.cma"
    #load "unix.cma"
    #load "extLib.cma"
    #load "zip.cma"
    #load "ptrees.cma"
    #load "javalib.cma"
    #load "sawja.cma"
</code>
</pre>
<p>Don't forget the associated <strong>#directory</strong>
directives that allow you to specify the paths where to find these
libraries.</p>
<p>You can also build a toplevel including all these libraries
using the command <strong>make ocaml</strong> in the sources
repository of <em>Sawja</em>. This command builds an executable
named <strong>ocaml</strong> which is the result of the
<strong>ocamlmktop</strong> command.</p>
<div id="loading-and-printing-a-program">
<h2><a href="#TOC">Loading and printing a program</a></h2>
<p>In this section, we present how to load a program with
<em>Sawja</em> and some basic manipulations we can do on it to
recover interesting information.</p>
<p>In order to test the efficiency of <em>Sawja</em>, we like to
work on huge programs. For instance we will use <em>Soot</em>, a
<em>Java Optimization Framework</em> written in <em>Java</em>,
which can be found at <a href=
"http://www.sable.mcgill.ca/soot">http://www.sable.mcgill.ca/soot</a>.
Once you have downloaded <em>Soot</em> and its dependencies, make
sure that the <strong>$CLASSPATH</strong> environment variable
contains the corresponding <strong>.jar</strong> files and the
<em>Java Runtime</em> <strong>rt.jar</strong>. The following sample
of code loads <em>Soot</em> program, given its main entry
point:</p>
<pre>
<code>    open Javalib
    open JBasics
    open JProgram
    let (prta,instantiated_classes) =
      JRTA.parse_program (Sys.getenv "CLASSPATH")
         (JBasics.make_cn "soot.Main", JProgram.main_signature)
</code>
</pre>
<p>It can be interesting to generate the <strong>.html</strong>
files corresponding to the parsed program <strong>prta</strong>. We
first need to build an <strong>info</strong> type.</p>
<pre>
<code>    (* p_class annots a class, saying if it may be instantiated
       or not. *)
    let p_class =
      (fun cn -&gt;
        let ioc = get_node prta cn in
          match ioc with
           | Class c -&gt;
             if ClassMap.mem (get_name ioc) instantiated_classes then
               ["Instantiated"] else ["Not instantiatied"]
           | _ -&gt; []
      )
</code>
</pre>
<pre>
<code>    (* p_method annots a method, saying if it is concrete or abstract,
       and if it has been parsed or not (by RTA). *)
    let p_method =
      (fun cn ms -&gt;
        let m = get_method (get_node prta cn) ms in
           match m with
            | AbstractMethod _ -&gt; ["Abstract Method"]
            | ConcreteMethod cm -&gt;
              let cms = make_cms cn ms in
              let parse =
                if ClassMethodMap.mem cms prta.parsed_methods then
                  "Parsed" else "Not parsed" in
                ["Concrete Method "; parse]
      )
</code>
</pre>
<pre>
<code>    (* There is no field annotation. *)
    let p_field = (fun _ _ -&gt; [])

    (* There is no program point annotation. *)
    let p_pp = (fun _ _ _ -&gt; [])

    (* This is the info type. *)
    let simple_info = 
      { JPrintHtml.p_class = p_class;
        JPrintHtml.p_field = p_field;
        JPrintHtml.p_method = p_method;
        JPrintHtml.p_pp = p_pp }
</code>
</pre>
<p>Then we just need to call the printing function:</p>
<pre>
<code>    let output = "./prta"
    let () = JPrintHtml.print_program ~info:simple_info prta output
</code>
</pre>
<dl>
<dt>Note:</dt>
<dd>The destination directory must exist, otherwise an exception
will be raised.</dd>
</dl>
</div>
<div id="transforming-a-program-with-bir">
<h2><a href="#TOC">Transforming a program with
<em>Bir</em></a></h2>
<p>In this section we present a sample of code transforming a
program loaded with <em>RTA</em> to <em>JBir</em> representation.
The procedure to obtain the <em>A3Bir</em> representation is
exactly the same.</p>
<pre>
<code>    let pbir = JProgram.map_program2
      (fun _ -&gt; JBir.transform ~bcv:false ~compress:false) prta
</code>
</pre>
<dl>
<dt>Warning:</dt>
<dd>Subroutines inlining is not totally handled in <em>JBir</em>
and <em>A3Bir</em>. If some transformed code contains such
subroutines, the exception <strong>JBir.Subroutine</strong> or
<strong>AB3Bir.Subroutine</strong> will be raised, respectively.
However, when transforming a whole program with the above function,
no exception will be raised because of the <em>lazy</em> evaluation
of code.</dd>
</dl>
<p>To see how <em>JBir</em> representation looks like, we can
pretty-print one class, for instance
<strong>java.lang.Object</strong>:</p>
<pre>
<code>    let obj = JProgram.get_node pbir JBasics.java_lang_object
    let () = JPrint.print_class (JProgram.to_ioc obj)
        JBir.print stdout
</code>
</pre>
<p>Or generate the <em>.html</em> files corresponding to
<em>JBir</em> program:</p>
<pre>
<code>    let output = "./pbir"
    let () = JPrintHtml.print_jbir_program pbir output
</code>
</pre>
<dl>
<dt>Note:</dt>
<dd>If some exceptions occur during <em>JBir</em> transformation,
the incriminated methods won't have any body in the <em>.html</em>
representation.</dd>
</dl>
</div>
<div id="writing-your-own-html-printer">
<h2><a href="#TOC">Writing your own HTML printer</a></h2>
<p>Here we study the case of <strong>JCode.jcode</strong> printer,
and show in details how it is implemented.</p>
<p>We remember that the module interface to implement is
<em>PrintInterface</em> whose signature is given below.</p>
<pre>
<code>module type PrintInterface =
sig
  type instr
  type code
  val iter_code : (int -&gt; instr -&gt; unit) -&gt; code Lazy.t -&gt; unit
  val method_param_names : code program -&gt; class_name -&gt;
     method_signature -&gt; string list option
  val inst_html : code program -&gt; class_name -&gt; method_signature -&gt;
    int -&gt; instr -&gt; elem list
  val jcode_pp :
    ('a program -&gt; class_name -&gt; method_signature -&gt; int -&gt; int) option
end
</code>
</pre>
<p>The type <strong>instr</strong> represents the instructions in
your code representation type <strong>code</strong>. Here,
<strong>instr</strong> corresponds to
<strong>JCode.jopcode</strong> and <strong>code</strong> is
<strong>JCode.jcode</strong>.</p>
<p>Then, you need to give an iterator on you code structure. This
function is really easy to write.</p>
<pre>
<code>    let iter_code f lazy_code =
      let code = Lazy.force lazy_code in
        Array.iteri
          (fun pp opcode -&gt;
            match opcode with
              | OpInvalid -&gt; ()
              | _ -&gt; f pp opcode
          ) code.c_code
</code>
</pre>
<p>You also need to provide a function that may associate names to
method parameters in the signature. Then, when generating the html
instructions you need to be consistent with those names. In our
implementation <em>JCodePrinter</em> in <em>jPrintHtml.ml</em>, we
use the source variables names when the local variable table exists
in the considered method. If you want to test your printer very
quickly, you can define:</p>
<pre>
<code>    let method_param_names _ _ _ = None
</code>
</pre>
<p>Now, we need to define how to display the instructions in html.
In order to do that, some html elements can be created by using
predefined functions in <em>JPrintHtml</em>. These functions are
<strong>simple_elem</strong>, <strong>value_elem</strong>,
<strong>field_elem</strong>, <strong>invoke_elem</strong> and
<strong>method_args_elem</strong>. The sample of code below will
help you to understand how you can use these functions. You are
also recommended to read the <em>API</em> documentation.</p>
<pre>
<code>    let inst_html program cs ms pp op =
      match op with
        | OpNew ccs -&gt;
          let v = TObject (TClass ccs) in
            [simple_elem "new"; value_elem program cs v]
        | OpNewArray v -&gt;
            [simple_elem "newarray"; value_elem program cs v]
        | OpGetField (ccs,fs) -&gt;
          let ftype = fs_type fs in
            [simple_elem "getfield";
             field_elem program cs ccs fs;
             simple_elem " : ";
             value_elem program cs ftype]
        | OpInvoke ((`Virtual o),cms) -&gt;
          let ccs = match o with
            | TClass ccs -&gt; ccs
            | _ -&gt; JBasics.java_lang_object in
              [simple_elem inst;
               invoke_elem program cs ms pp ccs cms;
               method_args_elem program cs ms]
        | ... -&gt; ...
        | _ -&gt;
          let inst =
            Javalib.JPrint.jopcode ~jvm:true op in
            [simple_elem inst]
</code>
</pre>
<p>The html elements have to be concatenated in a list and will be
displayed in the given order. The element returned by
<strong>simple_elem</strong> is raw text. The element returned by
<strong>value_elem</strong> refers to an html class file. The
element returned by <strong>field_elem</strong> is a link to the
field definition in the corresponding html class file. Field
resolution is done by the function <strong>resolve_field</strong>
of <em>JControlFlow</em>. If more than one field is resolved (it
can happen with interface fields), a list of possible links is
displayed. The element returned by <strong>invoke_elem</strong> is
a list of links refering to html class file methods that have been
resolved by the <strong>static_lookup_method</strong> function of
<strong>JProgram.program</strong>. The element returned by
<strong>method_args_elem</strong> is a list of
<strong>value_elem</strong> elements corresponding to the method
parameters. They are separated by commas and encapsulated by
parentheses, ready to be displayed.</p>
<p>If you don't want any html effect, the above function becomes
very simple:</p>
<pre>
<code>    let inst_html program _ _ _ op =
      let inst =
        Javalib.JPrint.jopcode ~jvm:true op in
        [simple_elem inst]
</code>
</pre>
<p>Finally, we need to define the <strong>jcode_pp</strong>
function, which associates a program point in the
<strong>code</strong> representation, to a program point in the
<strong>JCode.code</strong> representation. Here, we have the
identity.</p>
<pre>
<code>    let jcode_pp _ _ _ x = x
</code>
</pre></div>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1">
<p>F. Tip, J. Palsberg. <em>Scalable Propagation-Based Call Graph
Construction Algorithms</em>. OOPSLA 2000. See <a href=
"http://www.cs.ucla.edu/~palsberg/paper/oopsla00.pdf">http://www.cs.ucla.edu/~palsberg/paper/oopsla00.pdf</a>.
<a href="#fnref1" class="footnoteBackLink" title=
"Jump back to footnote 1">&#8617;</a></p>
</li>
<li id="fn2">
<p>D. Demange, T. Jensen and D. Pichardie. <em>A Provably Correct
Stackless Intermediate Representation For Java Bytecode</em>.
Research Report 7021, INRIA, 2009. See <a href=
"http://irisa.fr/celtique/ext/bir">http://irisa.fr/celtique/ext/bir</a>.
<a href="#fnref2" class="footnoteBackLink" title=
"Jump back to footnote 2">&#8617;</a></p>
</li>
</ol>
</div>
</body>
</html>
