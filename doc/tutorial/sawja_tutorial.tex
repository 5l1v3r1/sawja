%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% GENERATED FILE, DO NOT MODIFY.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass{article}
\usepackage{amsmath}
\usepackage[mathletters]{ucs}
\usepackage[utf8x]{inputenc}
\usepackage{hyperref}
% \usepackage{listings}
% \setlength{\parskip}{6pt plus 2pt minus 1pt}

\title{Sawja Tutorial}
\author{Nicolas Barr√©}

\begin{document}

\maketitle
\newpage

\tableofcontents
\newpage
\section{Introduction}

\emph{Sawja} is a library written in \emph{OCaml}, relying on the
\emph{Javalib} to provide a high level representation of
\emph{Java} byte-code programs. Whereas \emph{Javalib} is dedicated
to class per class loading, \emph{Sawja} introduces a notion of
program thanks to control flow algorithms. For instance, a program
can be loaded using various algorithms like
\emph{Class Reachability Analysis} (\emph{CRA}), a variant of
\emph{Class Hierarchy Analysis} algorithm (\emph{CHA}) or
\emph{Rapid Type Analysis} (\emph{RTA}). For now, \emph{RTA} is the
best compromise between loading time and precision of the call
graph. A version of \emph{XTA} is coming soon. To get more
information about control flow graph algorithms and their
complexity, you can consult the paper of Frank Tip and Jens
Palsberg%
\footnote{F. Tip, J. Palsberg.
\emph{Scalable Propagation-Based Call Graph Construction Algorithms}.
OOPSLA 2000. See
\href{http://www.cs.ucla.edu/~palsberg/paper/oopsla00.pdf}{http://www.cs.ucla.edu/\ensuremath{\sim}palsberg/paper/oopsla00.pdf}.}.

In \emph{Sawja}, classes and interfaces are represented by
interconnected nodes belonging to a common hierarchy. For example,
given a class node, it's easy to access its super class, its
implemented interfaces or its children classes. The next chapters
will give more information about the nodes and program data
structures.

Moreover, \emph{Sawja} provides some stack-less intermediate
representations of code, called \emph{JBir} and \emph{A3Bir}. Such
representations open the way to many analyses which can be built
upon them more naturally, better than with the byte-code
representation (e.g. \emph{Live Variable Analysis}). The
transformation algorithm, common to these representations, has been
formalized and proved to be semantics-preserving%
\footnote{D. Demange, T. Jensen and D. Pichardie.
\emph{A Provably Correct Stackless Intermediate Representation For Java Bytecode}.
Research Report 7021, INRIA, 2009. See
\href{http://irisa.fr/celtique/ext/bir}{http://irisa.fr/celtique/ext/bir}.}.

\emph{Sawja} also provides functions to map a program using a
particular code representation to another.

\section{Global architecture}

In this section, we present the different modules of \emph{Sawja}
and how they interact together. While reading the next sections, we
recommend you to have a look at \emph{Sawja} API at the same time.

\subsection{\emph{JProgram} module}

This module defines:

\begin{itemize}
\item
  the types representing the class hierarchy.
\item
  the program structure.
\item
  some functions to access classes, methods and fields (similar to
  \emph{Javalib} functions).
\item
  some functions to browse the class hierarchy.
\item
  a large set of program manipulations.
\end{itemize}
Classes and interfaces are represented by \textbf{class\_node} and
\textbf{interface\_node} record types, respectively. These types
are parametrized by the code representation type, like in
\emph{Javalib}. These types are private and cannot be modified by
the user. The only way to create them is to use the functions
\textbf{make\_class\_node} and \textbf{make\_interface\_node} with
consistent arguments. In practice, you will never need to build
them because the class hierarchy is automatically generated when
loading a program. You only need a read access to these record
fields.

The program structure contains:

\begin{itemize}
\item
  a map of all the classes referenced in the loaded program. These
  classes are linked together through the node structure.
\item
  a map of parsed methods. This map depends on the algorithm used to
  load the program (\emph{CRA}, \emph{RTA}, \ldots{}).
\item
  a static lookup method. Given the calling class name, the calling
  method signature, the invoke kind (virtual, static, \ldots{}), the
  invoked class name and method signature, it returns a set of
  potential couples of (\textbf{class\_name},
  \textbf{method\_signature}) that may be called.
\end{itemize}
\subsection{\emph{JCRA}, \emph{JRTA} and \emph{JRRTA} modules}

Each of these modules implements a function \textbf{parse\_program}
(the signature varies) which returns a program parametrized by the
\textbf{Javalib.jcode} representation.

In \emph{RTA}, the function \textbf{parse\_program} takes at least,
as parameters, a class-path string and a program entry point. The
\textbf{default\_entrypoints} value represents the methods that are
always called by \emph{Sun JVM} before any program is launched.

In \emph{CRA}, the function \textbf{parse\_program} takes at least,
as parameters, a class-path string and a list of classes acting as
entry points. The \textbf{default\_classes} value represents the
classes that are always loaded by \emph{Sun JVM}.

\emph{JRRTA} is a refinement of \emph{RTA}. It first calls
\emph{RTA} and then prunes the call graph.

If we compare these algorithms according to their precision on the
call-graph, and their cost (time and memory consumption), we get
the following order : \emph{CRA} \textless{} \emph{RTA} \textless{}
\emph{RRTA} \textless{} \emph{XTA}.

\subsection{\emph{JNativeStubs} module}

This module allows to define stubs for native methods, containing
information about native method calls and native object
allocations. Stubs can be stored in files, loaded and merged. The
format to describe stubs looks like:

\begin{verbatim}
    Method{type="Native" class="Ljava/lang/String;"
           name="intern" signature="()Ljava/lang/String;"}{
      VMAlloc{
        "Ljava/lang/String;"
        "[C"
      }
    }


    Method{type="Native" class="Ljava/io/UnixFileSystem;"
           name="getLength" signature="(Ljava/io/File;)J"}{
      Invokes{
        Method{type="Java" class="Ljava/lang/String;"
               name="getBytes" signature="(Ljava/lang/String;)[B"}
        }
    }
\end{verbatim}
\emph{JRTA} admits a stub file as optional argument to handle
native methods.

\subsection{\emph{JControlFlow} module}

\emph{JControlFlow} provides many functions related to class, field
an method resolution. Static lookup functions for
\textbf{invokevirtual}, \textbf{invokeinterface},
\textbf{invokestatic} and \textbf{invokespecial} are also present.

This module also contains an internal module \textbf{PP} which
allows to navigate through the control flow graph of a program.

\subsection{\emph{JBir} and \emph{A3Bir} modules}

These modules both declare a type \textbf{t} defining an
intermediate code representation. Both representations are
stack-less. \emph{A3Bir} looks like a three-address code
representation whereas expressions in \emph{JBir} can have
arbitrary depths.

Each module defines a function \textbf{transform} which takes as
parameters a concrete method and its associated
\textbf{JCode.code}, and returns a representation of type
\textbf{t}. This function coupled with
\textbf{JProgram.map\_program2} can be used to transform a whole
program loaded with \emph{RTA} algorithm for example.

\subsection{\emph{JPrintHtml} module}

This module provides one function per code representation to dump a
program into a set of \textbf{.html} files (one per class) related
together by the control flow graph. Each printing function takes as
parameters the program, the name of the output directory and a type
\textbf{info}. The type \textbf{info} is used to insert custom
annotations at different levels : class, method, field and program
point. A value \textbf{void\_info} is also given and can be used by
default.

In order to print your own code representations, this module also
provides a functor \emph{Make} that can be instantiated by a module
of signature \emph{PrintInterface}. This functor generates a module
of signature \emph{HTMLPrinter} containing a function
\textbf{print\_program}, similar to the others printing functions
present in \emph{JPrintHtml}. We will give an example in the
tutorial.

\section{Tutorial}

To begin this tutorial, open an \emph{OCaml} toplevel, for instance
using the \emph{Emacs} \textbf{tuareg-mode}, and load the following
libraries in the given order:

\begin{verbatim}
    #load "str.cma"
    #load "unix.cma"
    #load "extLib.cma"
    #load "zip.cma"
    #load "ptrees.cma"
    #load "javalib.cma"
    #load "sawja.cma"
\end{verbatim}
Don't forget the associated \textbf{\#directory} directives that
allow you to specify the paths where to find these libraries.

You can also build a toplevel including all these libraries using
the command \textbf{make ocaml} in the sources repository of
\emph{Sawja}. This command builds an executable named
\textbf{ocaml} which is the result of the \textbf{ocamlmktop}
command.

\subsection{Loading and printing a program}

In this section, we present how to load a program with \emph{Sawja}
and some basic manipulations we can do on it to recover interesting
information.

In order to test the efficiency of \emph{Sawja}, we like to work on
huge programs. For instance we will use \emph{Soot}, a
\emph{Java Optimization Framework} written in \emph{Java}, which
can be found at
\href{http://www.sable.mcgill.ca/soot}{http://www.sable.mcgill.ca/soot}.
Once you have downloaded \emph{Soot} and its dependencies, make
sure that the \textbf{\$CLASSPATH} environment variable contains
the corresponding \textbf{.jar} files and the \emph{Java Runtime}
\textbf{rt.jar}. The following sample of code loads \emph{Soot}
program, given its main entry point:

\begin{verbatim}
    open Javalib
    open JBasics
    open JProgram
    let (prta,instantiated_classes) =
      JRTA.parse_program (Sys.getenv "CLASSPATH")
         (JBasics.make_cn "soot.Main", JProgram.main_signature)
\end{verbatim}
It can be interesting to generate the \textbf{.html} files
corresponding to the parsed program \textbf{prta}. We first need to
build an \textbf{info} type.

\begin{verbatim}
    (* p_class annots a class, saying if it may be instantiated
       or not. *)
    let p_class =
      (fun cn ->
        let ioc = get_node prta cn in
          match ioc with
           | Class c ->
             if ClassMap.mem (get_name ioc) instantiated_classes then
               ["Instantiated"] else ["Not instantiatied"]
           | _ -> []
      )
\end{verbatim}
\begin{verbatim}
    (* p_method annots a method, saying if it is concrete or abstract,
       and if it has been parsed or not (by RTA). *)
    let p_method =
      (fun cn ms ->
        let m = get_method (get_node prta cn) ms in
           match m with
            | AbstractMethod _ -> ["Abstract Method"]
            | ConcreteMethod cm ->
              let cms = make_cms cn ms in
              let parse =
                if ClassMethodMap.mem cms prta.parsed_methods then
                  "Parsed" else "Not parsed" in
                ["Concrete Method "; parse]
      )
\end{verbatim}
\begin{verbatim}
    (* There is no field annotation. *)
    let p_field = (fun _ _ -> [])

    (* There is no program point annotation. *)
    let p_pp = (fun _ _ _ -> [])

    (* This is the info type. *)
    let simple_info = 
      { JPrintHtml.p_class = p_class;
        JPrintHtml.p_field = p_field;
        JPrintHtml.p_method = p_method;
        JPrintHtml.p_pp = p_pp }
\end{verbatim}
Then we just need to call the printing function:

\begin{verbatim}
    let output = "./prta"
    let () = JPrintHtml.print_program ~info:simple_info prta output
\end{verbatim}
\begin{description}
\item[Note:]
The destination directory must exist, otherwise an exception will
be raised.
\end{description}
\subsection{Transforming a program with \emph{Bir}}

In this section we present a sample of code transforming a program
loaded with \emph{RTA} to \emph{JBir} representation. The procedure
to obtain the \emph{A3Bir} representation is exactly the same.

\begin{verbatim}
    let pbir = JProgram.map_program2
      (fun _ -> JBir.transform ~bcv:false ~compress:false) prta
\end{verbatim}
\begin{description}
\item[Warning:]
Subroutines inlining is not totally handled in \emph{JBir} and
\emph{A3Bir}. If some transformed code contains such subroutines,
the exception \textbf{JBir.Subroutine} or
\textbf{AB3Bir.Subroutine} will be raised, respectively. However,
when transforming a whole program with the above function, no
exception will be raised because of the \emph{lazy} evaluation of
code.
\end{description}
To see how \emph{JBir} representation looks like, we can
pretty-print one class, for instance \textbf{java.lang.Object}:

\begin{verbatim}
    let obj = JProgram.get_node pbir JBasics.java_lang_object
    let () = JPrint.print_class (JProgram.to_ioc obj)
        JBir.print stdout
\end{verbatim}
Or generate the \emph{.html} files corresponding to \emph{JBir}
program:

\begin{verbatim}
    let output = "./pbir"
    let () = JPrintHtml.print_jbir_program pbir output
\end{verbatim}
\begin{description}
\item[Note:]
If some exceptions occur during \emph{JBir} transformation, the
incriminated methods won't have any body in the \emph{.html}
representation.
\end{description}
\subsection{Writing your own HTML printer}

Here we study the case of \textbf{JCode.jcode} printer, and show in
details how it is implemented.

We remember that the module interface to implement is
\emph{PrintInterface} whose signature is given below.

\begin{verbatim}
module type PrintInterface =
sig
  type instr
  type code
  val iter_code : (int -> instr -> unit) -> code Lazy.t -> unit
  val method_param_names : code program -> class_name ->
     method_signature -> string list option
  val inst_html : code program -> class_name -> method_signature ->
    int -> instr -> elem list
  val jcode_pp :
    ('a program -> class_name -> method_signature -> int -> int) option
end
\end{verbatim}
The type \textbf{instr} represents the instructions in your code
representation type \textbf{code}. Here, \textbf{instr} corresponds
to \textbf{JCode.jopcode} and \textbf{code} is
\textbf{JCode.jcode}.

Then, you need to give an iterator on you code structure. This
function is really easy to write.

\begin{verbatim}
    let iter_code f lazy_code =
      let code = Lazy.force lazy_code in
        Array.iteri
          (fun pp opcode ->
            match opcode with
              | OpInvalid -> ()
              | _ -> f pp opcode
          ) code.c_code
\end{verbatim}
You also need to provide a function that may associate names to
method parameters in the signature. Then, when generating the html
instructions you need to be consistent with those names. In our
implementation \emph{JCodePrinter} in \emph{jPrintHtml.ml}, we use
the source variables names when the local variable table exists in
the considered method. If you want to test your printer very
quickly, you can define:

\begin{verbatim}
    let method_param_names _ _ _ = None
\end{verbatim}
Now, we need to define how to display the instructions in html. In
order to do that, some html elements can be created by using
predefined functions in \emph{JPrintHtml}. These functions are
\textbf{simple\_elem}, \textbf{value\_elem}, \textbf{field\_elem},
\textbf{invoke\_elem} and \textbf{method\_args\_elem}. The sample
of code below will help you to understand how you can use these
functions. You are also recommended to read the \emph{API}
documentation.

\begin{verbatim}
    let inst_html program cs ms pp op =
      match op with
        | OpNew ccs ->
          let v = TObject (TClass ccs) in
            [simple_elem "new"; value_elem program cs v]
        | OpNewArray v ->
            [simple_elem "newarray"; value_elem program cs v]
        | OpGetField (ccs,fs) ->
          let ftype = fs_type fs in
            [simple_elem "getfield";
             field_elem program cs ccs fs;
             simple_elem " : ";
             value_elem program cs ftype]
        | OpInvoke ((`Virtual o),cms) ->
          let ccs = match o with
            | TClass ccs -> ccs
            | _ -> JBasics.java_lang_object in
              [simple_elem inst;
               invoke_elem program cs ms pp ccs cms;
               method_args_elem program cs ms]
        | ... -> ...
        | _ ->
          let inst =
            Javalib.JPrint.jopcode ~jvm:true op in
            [simple_elem inst]
\end{verbatim}
The html elements have to be concatenated in a list and will be
displayed in the given order. The element returned by
\textbf{simple\_elem} is raw text. The element returned by
\textbf{value\_elem} refers to an html class file. The element
returned by \textbf{field\_elem} is a link to the field definition
in the corresponding html class file. Field resolution is done by
the function \textbf{resolve\_field} of \emph{JControlFlow}. If
more than one field is resolved (it can happen with interface
fields), a list of possible links is displayed. The element
returned by \textbf{invoke\_elem} is a list of links refering to
html class file methods that have been resolved by the
\textbf{static\_lookup\_method} function of
\textbf{JProgram.program}. The element returned by
\textbf{method\_args\_elem} is a list of \textbf{value\_elem}
elements corresponding to the method parameters. They are separated
by commas and encapsulated by parentheses, ready to be displayed.

If you don't want any html effect, the above function becomes very
simple:

\begin{verbatim}
    let inst_html program _ _ _ op =
      let inst =
        Javalib.JPrint.jopcode ~jvm:true op in
        [simple_elem inst]
\end{verbatim}
Finally, we need to define the \textbf{jcode\_pp} function, which
associates a program point in the \textbf{code} representation, to
a program point in the \textbf{JCode.code} representation. Here, we
have the identity.

\begin{verbatim}
    let jcode_pp _ _ _ x = x
\end{verbatim}

\end{document}
